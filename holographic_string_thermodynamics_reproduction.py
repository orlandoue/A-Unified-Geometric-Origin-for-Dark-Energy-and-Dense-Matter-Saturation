# -*- coding: utf-8 -*-
"""Holographic_String_Thermodynamics_Reproduction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PzaHcl4y91bxeAsxADoXMRbTrktkXjHG
"""

# ==========================================
# Holographic String Thermodynamics: Numerical Reproduction
# Author: Orlando Miguel Urbina Gonzalez
# Journal: MNRAS (Submitted)
# Description: This script reproduces all figures and numerical derivations.
# ==========================================

# 1. SETUP & GLOBAL IMPORTS
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.integrate import odeint, quad
from scipy.optimize import curve_fit      # Faltaba esta librería
from matplotlib.patches import Ellipse    # Faltaba esta librería

# --- GLOBAL PARAMETERS (Unified) ---
ALPHA = 4.1          # Stiffness parameter (from Neutron Stars)
NU    = 0.002        # Holographic Elasticity (from Cosmology/DESI)
K_CUT = 1.0          # QCD Scale (GeV)
OM_M0 = 0.315        # Matter Density (Planck 2018)
H0    = 67.4         # Hubble Constant

print("--- STARTING REPRODUCTION SCRIPT ---")

# ==========================================
# SECTION 2: SPECTRAL UNIFICATION (FIGURE 1)
# ==========================================
print("\nGenerating Figure 1: Spectral Unification...")

def phi_paper1(k, alpha):
    """ Phenomenological Model (Lorentzian) """
    return 1 / (1 + alpha * k**2)

def phi_string_theory(k, alpha_prime):
    """ String Field Theory Vertex (Gaussian) """
    return np.exp(-alpha_prime * k**2)

def phi_sum_modes(k, alpha_prime, n_modes=10):
    """ Sum of Massive Modes """
    total = np.zeros_like(k)
    for n in range(1, n_modes + 1):
        mass_sq = n / alpha_prime
        total += 1 / (k**2 + mass_sq)
    total /= total[0]
    return total

# Data Generation
k_axis = np.linspace(0, 2.5, 500)
ALPHA_NS = ALPHA # Use global

# Fitting
popt_string, _ = curve_fit(phi_string_theory, k_axis[k_axis < 1], phi_paper1(k_axis[k_axis < 1], ALPHA_NS))
alpha_prime_fit = popt_string[0]

popt_sum, _ = curve_fit(lambda k, a: phi_sum_modes(k, a, 50), k_axis[k_axis < 1], phi_paper1(k_axis[k_axis < 1], ALPHA_NS))
alpha_sum_fit = popt_sum[0]

# Plotting Figure 1
plt.figure(figsize=(10, 7))
plt.plot(k_axis, phi_paper1(k_axis, ALPHA_NS), 'r-', linewidth=3, label=f'Paper I Model (Lorentzian, $\\alpha={ALPHA_NS}$)')
plt.plot(k_axis, phi_string_theory(k_axis, alpha_prime_fit), 'g--', linewidth=3, label=f'String Field Theory (Gaussian, $\\alpha\'={alpha_prime_fit:.2f}$)')
plt.plot(k_axis, phi_sum_modes(k_axis, alpha_sum_fit, 20), 'b:', linewidth=2, alpha=0.7, label='Sum of Massive String Modes')
plt.axvline(x=1.0, color='gray', linestyle='-.', label='Scale $k_{cut}$ (Planck/QCD Scale)')
plt.title('Figure 1: Spectral Unification', fontsize=14)
plt.xlabel('Momentum $k / k_{cut}$', fontsize=12)
plt.ylabel('Phase Space Suppression $\Phi(k)$', fontsize=12)
plt.legend(fontsize=11)
plt.grid(True, alpha=0.3)
# Inset
plt.axes([0.6, 0.5, 0.25, 0.25])
plt.plot(k_axis[:100], phi_paper1(k_axis[:100], ALPHA_NS), 'r-')
plt.plot(k_axis[:100], phi_string_theory(k_axis[:100], alpha_prime_fit), 'g--')
plt.title('Low Energy Limit')
plt.grid(True)
plt.xticks([]); plt.yticks([])
plt.show()

print(f"-> Unification Results: Alpha (NS) = {ALPHA_NS}, Derived Alpha' (String) = {alpha_prime_fit:.4f}")

# ==========================================
# SECTION 3 & 4: COSMOLOGY (FIGURES 2 & 3)
# ==========================================
print("\nGenerating Figures 2 & 3: Cosmology and DESI...")

Om_r0 = 0.00009
Om_de0 = 1.0 - OM_M0 - Om_r0
NU_STRING = NU # Use global

def E_squared(z, nu):
    return 1 + (OM_M0 / (1-nu)) * ((1+z)**(3*(1-nu)) - 1) + (Om_r0 / (1-nu)) * ((1+z)**(4*(1-nu)) - 1)

def equation_of_state_w(z, nu):
    E2 = E_squared(z, nu)
    dE2dz = (3*OM_M0 * (1+z)**(3*(1-nu) - 1))

    # Calculate densities
    rho_de = E2 - OM_M0 * (1+z)**3
    d_rho_de_dz = dE2dz - 3*OM_M0 * (1+z)**2

    if rho_de <= 1e-10: return -1.0
    return -1 + (1+z)/(3*rho_de) * d_rho_de_dz

# Simulation
z_range = np.linspace(0, 2.5, 500)
w_model = np.array([equation_of_state_w(z, NU_STRING) for z in z_range])
w_lcdm = -1.0 * np.ones_like(z_range)
H_model = H0 * np.sqrt(E_squared(z_range, NU_STRING))
H_lcdm = H0 * np.sqrt(OM_M0*(1+z_range)**3 + Om_de0)

# Plotting Figure 2
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10), sharex=True)
ax1.plot(z_range, w_lcdm, 'k--', label=r'Standard $\Lambda$CDM')
ax1.plot(z_range, w_model, 'r-', linewidth=3, label=f'Holographic Strings ($\\nu={NU_STRING}$)')
ax1.fill_between(z_range, -1.05, -0.95, color='gray', alpha=0.2)
ax1.fill_between(z_range, w_model - 0.02, w_model + 0.02, color='red', alpha=0.1)
ax1.set_ylabel(r'Equation of State $w(z)$')
ax1.set_title('Figure 2: Dynamic Dark Energy Prediction')
ax1.legend()
ax1.grid(True, alpha=0.3)

diff = (H_model - H_lcdm) / H_lcdm * 100
ax2.plot(z_range, np.zeros_like(z_range), 'k--')
ax2.plot(z_range, diff, 'b-', linewidth=2)
ax2.set_ylabel(r'Deviation from $\Lambda$CDM (%)')
ax2.set_xlabel('Redshift $z$')
ax2.grid(True, alpha=0.3)
plt.xlim(0, 2.5)
plt.tight_layout()
plt.show()

# CPL Parameters & Figure 3
def get_cpl_parameters(nu_param):
    z_samples = np.linspace(0, 1.0, 100)
    a_samples = 1 / (1 + z_samples)
    w_vals = [equation_of_state_w(z, nu_param) for z in z_samples]
    coeffs = np.polyfit(1 - a_samples, w_vals, 1)
    return coeffs[1], coeffs[0] # w0, wa

nu_values = np.linspace(0.0001, 0.005, 20)
traj_w0, traj_wa = [], []
for n in nu_values:
    w0, wa = get_cpl_parameters(n)
    traj_w0.append(w0); traj_wa.append(wa)

my_w0, my_wa = get_cpl_parameters(NU_STRING)
desi_w0, desi_wa = -0.827, -0.75

# Plotting Figure 3
fig, ax = plt.subplots(figsize=(9, 7))
ax.plot(-1, 0, 'k*', markersize=15, label='$\Lambda$CDM')
ellipse1 = Ellipse((desi_w0, desi_wa), width=0.35, height=1.2, angle=-30, edgecolor='blue', facecolor='blue', alpha=0.2, label='DESI Constraints')
ax.add_patch(ellipse1)
ax.plot(traj_w0, traj_wa, 'r-', label='String Trajectory')
ax.plot(my_w0, my_wa, 'ro', markersize=10, markeredgecolor='black', label=f'Our Model')
ax.set_xlabel('$w_0$'); ax.set_ylabel('$w_a$')
ax.set_title('Figure 3: Phase Space Constraints')
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(-1.2, -0.7); ax.set_ylim(-1.5, 0.5)
plt.show()

print(f"-> DESI Results: w0 = {my_w0:.4f}, wa = {my_wa:.4f}")

# ==========================================
# SECTION 4.3: S8 TENSION (FIGURE 4)
# ==========================================
print("\nGenerating Figure 4: Structure Formation & S8...")

data_fs8 = np.array([[0.067, 0.423, 0.055], [0.17, 0.51, 0.06], [0.32, 0.384, 0.095],
                     [0.57, 0.441, 0.043], [0.77, 0.490, 0.18], [0.80, 0.470, 0.08]])
sigma8_0_lcdm = 0.811

def hubble_E_s8(z, nu):
    return np.sqrt(1 + (OM_M0/(1-nu)) * ((1+z)**(3*(1-nu)) - 1))

def growth_ode(y, x, nu):
    delta, delta_prime = y
    a = np.exp(x); z = 1/a - 1
    E = hubble_E_s8(z, nu)
    Omega_m_z = (OM_M0 * (1+z)**(3*(1-nu))) / E**2
    friction = 2.0 - 1.5 * Omega_m_z
    source = 1.5 * Omega_m_z * (1 - 2*nu)
    return [delta_prime, -friction * delta_prime + source * delta]

a_start = 0.01; x_span = np.linspace(np.log(a_start), 0, 500); y0 = [a_start, a_start]
z_span = np.exp(-x_span) - 1

# Solve LCDM vs Strings
sol_lcdm = odeint(growth_ode, y0, x_span, args=(0.0,))
fs8_lcdm = sigma8_0_lcdm * (sol_lcdm[:, 0] / sol_lcdm[-1, 0]) * (sol_lcdm[:, 1] / sol_lcdm[:, 0])

sol_string = odeint(growth_ode, y0, x_span, args=(NU_STRING,))
fs8_string = (sigma8_0_lcdm * (1.0 - 5*NU_STRING)) * (sol_string[:, 0]/sol_string[-1, 0]) * (sol_string[:, 1] / sol_string[:, 0])

# Plotting Figure 4
plt.figure(figsize=(10, 6))
plt.errorbar(data_fs8[:,0], data_fs8[:,1], yerr=data_fs8[:,2], fmt='o', color='black', label='Data')
plt.plot(z_span, fs8_lcdm, 'k--', linewidth=2, label='Standard $\Lambda$CDM')
plt.plot(z_span, fs8_string, 'r-', linewidth=3, label=f'Holographic Strings')
plt.xlim(0, 1.2); plt.ylim(0.3, 0.65)
plt.xlabel('Redshift $z$'); plt.ylabel(r'$f\sigma_8(z)$')
plt.title('Figure 4: S8 Tension Resolution')
plt.legend(); plt.grid(True, alpha=0.3)
plt.show()

# ==========================================
# SECTION 5.3: BLACK HOLE (FIGURE 5)
# ==========================================
print("\nGenerating Figure 5: Black Hole Regularization...")

def density_integrand_std(k): return k**3 / (2*np.pi**2)
def density_integrand_str(k, a, kc): return (k**3 / (2*np.pi**2)) * np.exp(-a * (k/kc)**2)

k_vals = np.linspace(0, 3.0, 100)
rho_std = [quad(density_integrand_std, 0, kl)[0] for kl in k_vals]
rho_str = [quad(density_integrand_str, 0, kl, args=(ALPHA, K_CUT))[0] for kl in k_vals]

plt.figure(figsize=(8, 6))
plt.plot(k_vals, rho_std, 'k--', label='Standard GR (Singularity)', alpha=0.6)
plt.plot(k_vals, rho_str, 'r-', linewidth=3, label=f'Holographic Strings ($\\alpha={ALPHA}$)')
plt.axhline(y=rho_str[-1], color='r', linestyle=':', label='Hagedorn Density')
plt.title('Figure 5: Black Hole Regularization')
plt.xlabel('Energy Scale $k$ [GeV]'); plt.ylabel('Energy Density $\\rho$')
plt.xlim(0, 2.5); plt.ylim(0, max(rho_str)*1.5)
plt.legend(); plt.grid(True, alpha=0.3)
plt.show()

print(f"-> Max Density: {rho_str[-1]:.4e} GeV^4")
print("\n--- REPRODUCTION COMPLETE ---")

# ==========================================
# GRÁFICA 6: TABLA DE PARÁMETROS (RESUMEN)
# ==========================================

# 1. Datos exactos con la corrección de la fuente (PSR J0952-060)
# Usamos r"" antes de las comillas para evitar advertencias de sintaxis con LaTeX
table_data = [
    [r"Stiffness ($\alpha$)",      "4.10",           "Neutron Star (PSR J0952-060)"],
    [r"Cutoff ($k_{\rm cut}$)",    "1.0 GeV",        "QCD Scale"],
    [r"Elasticity ($\nu$)",        "0.002",          "DESI DR2 (This Work)"],
    [r"String Length ($\ell_s$)",  "0.399 fm",       "Derived"],
    [r"Tension ($T_s$)",           r"0.0388 GeV$^2$","Derived"],
    [r"Hagedorn Temp ($T_H$)",     "39.3 MeV",       r"Derived ($T \sim m_\pi / \pi$)"]
]

columns = ["Parameter", "Value", "Source"]

# 2. Crear DataFrame
df_params = pd.DataFrame(table_data, columns=columns)

# 3. Configuración de la figura independiente
plt.figure(figsize=(10, 5)) # Creamos una figura nueva
ax_table = plt.gca()        # Obtenemos el eje actual
ax_table.axis('tight')
ax_table.axis('off')

# 4. Dibujar la tabla
the_table = ax_table.table(
    cellText=df_params.values,
    colLabels=columns,
    cellLoc='center',
    loc='center'
)

# 5. Estilo visual tipo "Paper" (Líneas horizontales limpias)
the_table.auto_set_font_size(False)
the_table.set_fontsize(12)
the_table.scale(1.2, 2.0) # Ajuste de escala (ancho, alto) de celdas

for (row, col), cell in the_table.get_celld().items():
    # Bordes: solo horizontales
    cell.set_edgecolor('black')
    if col >= 0:
        cell.visible_edges = 'horizontal'

    # Encabezado en negrita y línea más gruesa
    if row == 0:
        cell.set_text_props(weight='bold')
        cell.set_linewidth(1.5)
    else:
        cell.set_linewidth(0.5)

plt.title("Physical Parameters Used in the Model", y=0.95, fontsize=14)

# Guardar
plt.savefig('grafica_6_tabla_parametros.png', bbox_inches='tight', dpi=300)
print("Gráfica 6 (Tabla) guardada exitosamente.")

# Mostrar todo al final
plt.show()

